# Print Completed or Failed Based On The Last
# Command Exit Status.
function _print-cmd-status {
  if [[ ${?} -eq 0 ]]; then
    echo "Completed."
  else
    echo "Failed."
  fi
}

# Print A Header Used For CLI Output
# $1 = Header Text
function _print-header {
  local header_char="*"
  local header_cols=30
  local printed_header_char=0
  
  while [[ ${printed_header_char} -lt ${header_cols} ]]; do
    echo -n ${header_char}
    ((printed_header_char++))
  done
  
  echo "\n${1}"

  printed_header_char=0

  while [[ ${printed_header_char} -lt ${header_cols} ]]; do
    echo -n ${header_char}
    printed_header_char=$[${printed_header_char}+1]
  done

  echo "\n"
}

# Create An Entry In aws-vault
# $1 = Name Of New AWS Vault Entry
function aws-vault-add {
  if [[ ! -z ${1} ]]; then
    echo "Adding entry ${1} to aws-vault"
    aws-vault add ${1}
    entry_added=`aws-vault list | grep -i "${1}"`

    if [[ ! -z ${entry_added} ]]; then
      echo "Entry ${1} was added to aws-vault"
    else
      echo "[ERROR] Entry ${1} was not added to aws-vault"
    fi
  fi
}

# Decode A Base 64 Input And Save It As A Clear Text File
# $1 = File To Decode
function base64-decode {
  if [[ -f ${1} ]]; then
    cat ${1} | base64 -d  > ${1}.clear
  fi
}

# Take A Clear Text Input And Save It As A Base 64 Encoded File
# $1 = File To Encode
function base64-encode {
  if [[ -f ${1} ]]; then
    base64 ${1} > ${1}.b64
  fi
}

# Update / Upgrade Homebrew
function brew-update {
  _print-header "Updating HomeBrew Apps"

  brew update
  brew upgrade
}

# Cache GPG And SSH Keys Used For Bitbucket
function cache-all-keys {
  local host_index=1

  _print-header "Caching Bitbucket Keys"

  keychain-unlock ${GIT_KEYCHAIN}
  
  eval $(ssh-agent) > /dev/null 2>&1
  
  for git_host in ${GIT_HOSTS}; do
    #GPG Key Caching
    #Fetch GPG Key Passphrase From Keychain 
    local gpg_key_passphrase=$(security find-generic-password -w -s "${git_host}_gpg-key" ${GIT_KEYCHAIN})

    #Get GPG Fingerprint 
    local fingerprint=($(gpg --list-keys --fingerprint -a "${GIT_EMAILS[${host_index}]}"| sed -n '2 p' | awk '{ gsub(/ /,""); print }'))

    echo -n "Caching ${git_host} GPG Key..."

    touch /tmp/tmp_gpg.txt

    gpg --encrypt --pinentry-mode=loopback --batch --sign --yes \
        --default-key ${fingerprint} --passphrase ${gpg_key_passphrase} \
        --recipient ${GIT_EMAILS[${host_index}]} /tmp/tmp_gpg.txt &> /dev/null

    _print-cmd-status

    rm /tmp/tmp_gpg.txt

    #SSH Key Caching
    #Fetch SSH Key Passphrase From Keychain
    export SSH_KEY_PASS=$(security find-generic-password -w -s "${git_host}_ssh-key" ${GIT_KEYCHAIN})

    echo -n "Caching ${git_host} SSH Key..."
    
    #Cache SSH Key
    local ssh_key=$(openssl rsa -in ${GIT_SSH_KEYS[${host_index}]} -passin env:SSH_KEY_PASS 2> /dev/null)
    ssh-add -q - <<< "${ssh_key}"

    _print-cmd-status
    
    echo ""

    # Cleanup
    unset fingerprint
    unset gpg_key_passphrase
    unset keychain_password
    unset SSH_KEY_PASS
    unset ssh_key
    
    ((host_index++))
  done

  #Lock Keychain
  echo -n "Locking Keychain..."

  keychain-lock ${GIT_KEYCHAIN}

  _print-cmd-status
}

# Generate A Certificate Signing Request From A Java Keystore
# $1 = Keystore Name
# $2 = Certificate Alias
function gen-csr {
  keytool -certreq -keystore ${1} -alias ${2} -file ${2}.csr
}

# Lock A MacOs Keychain
# $1 = The Name Of The Keychain To Lock
function keychain-lock {
  if [[ -n ${1} ]]; then
    security lock-keychain ${1}
  fi
}

# Unlock A MacOS Keychain
# $1 = The Name Of The Keychain To Unlock
function keychain-unlock {
  if [[ -z ${1} ]]; then
    echo "[ERROR] No Keychain Name Passed To Function."
    return 1
  fi

  echo -n "Keychain Unlock Password: "
  read -s keychain_password
  echo "\n"

  if [[ -n ${keychain_password} ]]; then
    echo -n "Unlocking keychain..."

    security unlock-keychain -p ${keychain_password} ${1} 2> /dev/null
    
    _print-cmd-status
    echo "" 
  else
    echo "Failed."
    echo "[ERROR] No Password Entered."
    return 1  
  fi
}

# List All Aliases And Functions Contained In ~/.bash_aliases
function list-aliases-and-functions() {
  shell_type=$(basename ${SHELL})

  printf "\n==============\nCustom Aliases\n==============\n\n"
  grep "^alias" ~/.${shell_type}_aliases | sort | sed 's/alias //g'

  printf "\n================\nCustom Functions\n================\n\n"
  grep "^function" ~/.${shell_type}_functions | sort | sed 's/function //g' | sed 's/\ {//g'
  printf "\n"
}

# Map Personal Drive
function map-personal-drive {
  _print-header "Mapping Personal Network Drive"

  if [[ -z $(mount | grep $(basename ${LEGACY_NETWORK_PERSONAL_DRIVE})) ]]; then  
    open ${LEGACY_NETWORK_PERSONAL_DRIVE}
    _print-cmd-status
  else
    echo "Drive Already Mapped."
  fi

}

# Automate The Daily Update Tasks
function morning-routine {
  cache-all-keys
  echo ""
   
  brew-update
  echo ""
  
  map-personal-drive
  echo ""

  git-update-branches all
}

# Login To Vault And Get A Token
# $1 = RES User Name
function vault-login {
  export VAULT_TOKEN=`vault login -token-only -method=ldap username=${1}`
  
  echo -n "Logging into Vault (${VAULT_ADDR})..."

  if [[ -n ${VAULT_TOKEN} ]]; then
    echo "Completed."
  else
    echo "Failed."
  fi
}

# List All Certificate Entries In A Java Keystore
# $1 = Keystore File
function view-jks-certificate-entries {
  openssl x509 -in ${1} -noout -text | head -11
}
